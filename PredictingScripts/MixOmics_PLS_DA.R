# MixOmics PLS-DA
# E. Lamont
# 2/23/26

# I think this becomes a predictive model maybe??

# Partial Least Squares Discriminant Analysis (PLS-DA) is a linear, multivariate model which uses the PLS algorithm to allow classification of categorically labelled data. PLS-DA seeks for components that best separate the sample groups, whilst the sparse version also selects variables that best discriminate between groups.

# https://mixomics.org/methods/spls-da/
# https://mixomicsteam.github.io/mixOmics-Vignette/id_02.html#id_02
# https://mixomics.org/case-studies/splsda-srbct-case-study-2/

# if (!requireNamespace("BiocManager", quietly = TRUE))
#   install.packages("BiocManager")
# BiocManager::install("mixOmics")
library(mixOmics)

# I guess I can use log2(TPM+1) or do the EdgeR CPM...

source("Import_data.R")


###########################################################
####################### PROCESS DATA ######################

myX <- GoodSamples60_tpmf %>% # Using TPM to start...
  dplyr::select(-contains("THP1")) %>%
  dplyr::select(-contains("Broth")) %>% # Lets take out broth as well
  t()

# Remove genes (columns) that are all zero
myX <- myX[, colSums(myX) != 0] # Remove columns that are all zero so the scale works for prcomp

# Want this to be Type2 I guess 
my_pipeSummary2 <- my_pipeSummary %>%
  slice(match(rownames(myX), SampleID2)) # Match the rows then just keep the one that are the same
stopifnot(all(rownames(myX) %in% my_pipeSummary2$SampleID2))
myY <- my_pipeSummary2 %>%
  pull(Type2) %>%
  factor()

summary(myY)
# W0 sputum (cure) W0 sputum (relapse)    W2 sputum (cure) W2 sputum (relapse) 
# 32                  11                   8                   5 


###########################################################
################# PCA PRELIMINARY ANALYSIS ################
# As in most cases when developing models, exploring the data to determine the major sources of variation is a good first step. PCA will be used for this. As described in the PCA Methods Page, centering and scaling is recommended to homogenize the variance across the genes. ncomp is set to an arbitrarily high number to understand the captured variance across cotheremponents.

# run pca method on data
pca.1 = pca(myX, ncomp = 10, center = TRUE, scale = TRUE) 
plot(pca.1)  # barplot of the eigenvalues (explained variance per component)
# Saved with Export

# Two components would be sufficient to explain a moderate proportion of the data’s variance according to Figure 1. Next, the data is projected onto these two components to attempt to observe sources of variation.
PCA1 <- plotIndiv(pca.1, group = my_pipeSummary2$Type2, ind.names = FALSE, # plot the samples projected 
                  legend = TRUE, title = 'MixOmics PCA') # onto the PCA subspace
PCA1$graph
ggsave(PCA1$graph,
       file = paste0("PCA1_AllGoodSputum_v1.pdf"),
       path = "Figures/PredictiveModeling/Mixomics_PLSDA",
       width = 8, height = 5, units = "in")


###########################################################
################## INITIAL sPLS-DA MODEL ##################

my.splsda <- splsda(myX, myY, ncomp = 10)  # set ncomp to 10 for performance assessment later

# A PLS-DA model is fitted with ten components to evaluate the performance and the number of components necessary for the final model. 
# The background.predict() function can also be utilised to depict the separation of class labels. This plot provides intuition on how novel samples would be classified according to the model generated by sPLS-DA.

# plot the samples projected onto the first two components of the PLS-DA subspace
PLSDA_1 <- plotIndiv(my.splsda , comp = 1:2,
                     group = my_pipeSummary2$Type2, ind.names = FALSE,  # colour points by class
                     ellipse = TRUE, # include 95% confidence ellipse for each class
                     legend = TRUE, title = 'PLSDA with confidence ellipses')
PLSDA_1$graph
ggsave(PLSDA_1$graph,
       file = paste0("PLSDA1_AllGoodSputum_v1.pdf"),
       path = "Figures/PredictiveModeling/Mixomics_PLSDA",
       width = 8, height = 5, units = "in")

# use the max.dist measure to form decision boundaries between classes based on PLS-DA data
background = background.predict(my.splsda, comp.predicted=2, dist = "max.dist")

# plot the samples projected onto the first two components of the PLS-DA subspace
PLSDA_2 <- plotIndiv(my.splsda, comp = 1:2,
                     group = my_pipeSummary2$Type2, ind.names = FALSE, # colour points by class
                     background = background, # include prediction background for each class
                     legend = TRUE, title = "PLSDA with prediction background")
PLSDA_2$graph
ggsave(PLSDA_2$graph,
       file = paste0("PLSDA2_AllGoodSputum_v1.pdf"),
       path = "Figures/PredictiveModeling/Mixomics_PLSDA",
       width = 8, height = 5, units = "in")


###########################################################
###################### TUNING sPLS-DA #####################

## SELECTING THE NUMBER OF COMPONENTS ##
# The ncomp Parameter

# The number of components to use is a crucial decision and is dictated by the performance of the PLS-DA model - i.e. its ability to correctly classify novel samples. The perf() function is used for this exactly. This is done with repeated cross-validation. Based on the output of this function, the optimal number of components to use can be identified.
# 
# A three-fold, 10 repeat cross-validation procedure is utilised here. Generally, for datasets with numerous samples, at least 10 folds is recommended. 3 or 5 folds is appropriate for smaller datasets and those with minimal samples should use Leave-One-Out (LOO) validation. Consider using 50-100 repeats to reduce the impact of the randomly allocated folds during each repeat.
# 
# The overall error rate (OER) and balanced error rate (BER) for the three different distance metrics (explained further below) across the first ten components are depicted in Figure 4.

# undergo performance evaluation in order to tune the number of components to use
perf.splsda <- perf(my.splsda, validation = "Mfold",
                    folds = 5, nrepeat = 10, # use repeated cross-validation
                    progressBar = FALSE, auc = TRUE) # include AUC values

# plot the outcome of performance evaluation across all ten components
plot(perf.splsda, col = color.mixo(5:7), sd = TRUE,
     legend.position = "horizontal")

# This looks pretty different to what they are showing...


# A more empirical way to select this number is through the $choice.ncomp component of the perf() output object. It runs t-tests for a significant different in mean error rate across components. Using the max.dist metric, this suggests that the optimal number of components is 1!!!. 

perf.splsda$choice.ncomp # what is the optimal value of components according to perf()
# max.dist centroids.dist mahalanobis.dist
# overall        1              1                1
# BER            1              1                1

## SELECTING THE NUMBER OF VARIABLES ##
# The keepX Parameter

# In order to determine the number of variables used to construct each latent component, the tune.splsda() function is utilised. This is performed iteratively, such that components are tuned one at a time. Through this function, the classification error rate can be extracted and averaged across folds and repeats. As mentioned above, an appropriate number of repeats would be around 50-100.
# 
# Up to four components were selected as per Figure 4. In this case, five-fold cross validation was repeated ten times using the BER of max.dist as the performance measure - where minimisation was optimal. The cpus parameter allows for the use of parallelisation of computation as tuning can take a long time on low-to-mid range processors.
# 
# The output of the tuning is shown in Figure 5. The diamond indicates the optimal number of variables to keep for a given component, selected by which keepX value achieves the lowest classification error rate as determined with a one-sided t−test. The error bars indicate the standard deviation across the repeated, cross-validated folds.

# grid of possible keepX values that will be tested for each component
list.keepX <- c(1:10,  seq(20, 300, 10))

# undergo the tuning process to determine the optimal number of variables
tune.splsda <- tune.splsda(myX, myY, ncomp = 4, # calculate for first 4 components
                                 validation = 'Mfold',
                                 folds = 5, nrepeat = 10, # use repeated cross-validation
                                 dist = 'max.dist', # use max.dist measure
                                 measure = "BER", # use balanced error rate of dist measure
                                 test.keepX = list.keepX)

plot(tune.splsda, col = color.jet(4)) # plot output of variable number tuning

# FIGURE 5: Tuning keepX for the sPLS-DA performed on the SRBCT gene expression data. Each coloured line represents the balanced error rate (y-axis) per component across all tested keepX values (x-axis) with the standard deviation based on the repeated cross-validation folds. As sPLS-DA is an iterative algorithm, values represented for a given component (e.g. comp 1 to 2) include the optimal keepX value chosen for the previous component (comp 1).

# The above figure also aids in tuning the number of components. While the tuning of component number (through perf()) yielded an optimal value of 4, conflicting results can be seen after the use of tune.splsda(), such that the optimal value is claimed to be 3. After the optmisation of the selected features, the fourth component seemingly minimises the BER negligibly.

tune.splsda$choice.ncomp$ncomp # what is the optimal value of components according to tune.splsda()
# [1] 4

# The exact quantity of features to use for each component can also be extracted from this object:
tune.splsda$choice.keepX # what are the optimal values of variables according to tune.splsda()
# comp1 comp2 comp3 comp4 
# 20     9     1     2 

# These values are stored to form the final, optimised model.
optimal.ncomp <- tune.splsda$choice.ncomp$ncomp # 4
optimal.keepX <- tune.splsda$choice.keepX[1:optimal.ncomp]


###########################################################
####################### FINAL MODEL #######################

# Using all the tuned parameters from above, the final sPLS-DA model can be formed.

# form final model with optimised values for component and variable count
final.splsda <- splsda(myX, myY, 
                       ncomp = optimal.ncomp, 
                       keepX = optimal.keepX)

###########################################################
####################### FINAL PLOTS #######################

Tuned_PLSDA_1 <- plotIndiv(final.splsda, comp = c(1,2), # plot samples from final model
                           group = my_pipeSummary2$Type2, ind.names = FALSE, # colour by class label
                           ellipse = TRUE, legend = TRUE, # include 95% confidence ellipse
                           title = 'Tuned sPLS-DA on SRBCT, comp 1 & 2')

Tuned_PLSDA_1$graph
# ggsave(Tuned_PLSDA_1$graph,
#        file = paste0("Tuned_PLSDA1_AllGoodSputum_v1.pdf"),
#        path = "Figures/PredictiveModeling/Mixomics_PLSDA",
#        width = 8, height = 5, units = "in")

Tuned_PLSDA_2 <- plotIndiv(final.splsda, comp = c(1,3), # plot samples from final model
                           group = my_pipeSummary2$Type2, ind.names = FALSE,  # colour by class label
                           ellipse = TRUE, legend = TRUE, # include 95% confidence ellipse
                           title = 'Tuned sPLS-DA on SRBCT, comp 1 & 3')
Tuned_PLSDA_2$graph
# ggsave(Tuned_PLSDA_2$graph,
#        file = paste0("Tuned_PLSDA2_AllGoodSputum_v1.pdf"),
#        path = "Figures/PredictiveModeling/Mixomics_PLSDA",
#        width = 8, height = 5, units = "in")


# A Cluster Image Map (CIM) is shown in Figure 7. It depicts the expression levels of each gene (selected for component construction) for every sample. Euclidean distance with a complete agglomeration method were used to yield this CIM. It can be seen that certain sets of genes had homogeneous expression for different classes. For example, nearly half of the genes had high expression with the EWS (blue) tumour.

# set the styling of the legend to be homogeneous with previous plots
legend=list(legend = levels(myY), # set of classes
            col = unique(color.mixo(myY)), # set of colours
            title = "Sputum Type", # legend title
            cex = 0.7) # legend size
# generate the CIM, using the legend and colouring rows by each sample's class
cim <- cim(final.splsda, row.sideColors = color.mixo(myY), 
           legend = legend)
# Error in cim plot: figure margins too large. See ?cim for help.


## Variable Plots ##
# The stability of a given feature is defined as the proportion of cross validation folds (across repeats) where it was selected for to be used for a given component. Stability values can be extracted via perf.splsda.srbct$features$stable. These stabilities can be plotted, seen in Figure 8. Those with the highest stability are likely to be much more “important” for a given component. The features used for the first component had consistently lower stability than the other two. This can be explained as there are various combinations of genes that are discriminative on component 1, whereas the number of combinations decreases as component 2 is formed.

# form new perf() object which utilises the final model
perf.splsda <- perf(final.splsda, 
                          folds = 5, nrepeat = 10, # use repeated cross-validation
                          validation = "Mfold", dist = "max.dist",  # use max.dist measure
                          progressBar = FALSE)

# plot the stability of each feature for the first three components, 'h' type refers to histogram
par(mfrow=c(1,3))
plot(perf.splsda$features$stable[[1]], type = 'h', 
     ylab = 'Stability', 
     xlab = 'Features', 
     main = '(a) Comp 1', las =2)
plot(perf.splsda$features$stable[[2]], type = 'h', 
     ylab = 'Stability', 
     xlab = 'Features', 
     main = '(b) Comp 2', las =2)
plot(perf.splsda$features$stable[[3]], type = 'h', 
     ylab = 'Stability', 
     xlab = 'Features',
     main = '(c) Comp 3', las =2)
# Saved with Export


# Another variable plot to be used is the correlation circle plot. Figure 9 depicts this. By considering both the correlation circle plot and the sample plot (Figure 6(a)), a group of genes with a positive correlation with component 1 (EH domain, proteasome etc.) are observed to be associated with the BL samples. Two groups of genes are either positively or negatively correlated with component 2. These genes are likely to characterise either the NB and RMS classes, or the EWS class.

plotVar(final.splsda, comp = c(1,2), cex = 3) # generate correlation circle plot
# Saved with Export

###########################################################
######################## PREDICTION #######################

# When undergoing prediction, the (s)PLS-DA data must first be segmented into training and testing, such that there are novel samples to evaluate performance on. Otherwise, it runs the risk of “overfitting”, resulting in inflated predictive ability scores.

train <- sample(1:nrow(myX), 40) # randomly select 40 samples in training
test <- setdiff(1:nrow(myX), train) # rest is part of the test set

# store matrices into training and test set:
X.train <- myX[train, ]
X.test <- myX[test,]
Y.train <- myY[train]
Y.test <- myY[test]

# A model is then trained on the training data. Note that the previously calculated optimal.keepX values are used here. In real scenarios, the training model should be tuned itself. It is crucial that when tuning the training model, it is done in the absence of the testing data. This also reduces likelihood of overfitting.

# train the model
train.splsda <- splsda(X.train, Y.train, ncomp = optimal.ncomp, keepX = optimal.keepX)

# The model is then applied on the test set using a specific distance metric. In this case, the Mahalanobis distance was used (arbitrarily).

# use the model on the Xtest set
predict.splsda <- predict(train.splsda, X.test, 
                                dist = "mahalanobis.dist")

# To evaluate the predictive performance, confusion matrices can be used. Directly below is such a matrix for a model using just the first two components. Only one misclassification were made - one sample was claimed to belong to the NB class when it truthfully belonged to the RMS class.

# evaluate the prediction accuracy for the first two components
predict.comp2 <- predict.splsda$class$mahalanobis.dist[,2]
table(factor(predict.comp2, levels = levels(Y)), Y.test)

# Below is the equivalent matrix for the model using all three components. It can be seen that the classification accuracy increased.

# evaluate the prediction accuracy for the first three components
predict.comp3 <- predict.splsda$class$mahalanobis.dist[,3]
table(factor(predict.comp3, levels = levels(Y)), Y.test)

###########################################################
##################### PERFORMANCE PLOTS ###################

# AUC plots can be used for performance evaluation. AUC scores are calculated from training cross-validation sets and averaged in the perf() function (perf.plsda.srbct$auc and perf.plsda.srbct$auc.all for one vs. one class or one vs. all classes respectively).

# However, ROC and AUC criteria may not be particularly insightful, or be in agreement with the PLSDA performance, as the prediction threshold in PLS-DA is based on specified distance. AUROC curves use a cutoff that maximises specificity and sensitivity rather than this distance and hence should be used a merely a complementary tool.

# AUROC plots for models containing one component and three components can be seen in Figure 10 (a) and (b) respectively. Figure 10(a) suggests that the sPLS-DA model can distinguish BL subjects from the other groups with a high true positive and low false positive rate, while the model is less well able to distinguish samples from other classes on component 1. The model including all three components (Figure 10(b)) has a perfect classification accuracy. While the model is definitely improved by the addition of two components, it is the small testing set size which allows for this perfect score.

# Note that if print = TRUE (as is by default), numerical output including AUC and a Wilcoxon test p-value for each ‘one vs. other’ class comparisons that are performed per component will be printed.

auc.splsda = auroc(final.splsda, roc.comp = 1, print = FALSE) # AUROC for the first component
auc.splsda = auroc(final.splsda, roc.comp = 3, print = F) # AUROC for all three components
# Saved via export


# https://mixomics.org/methods/spls-da/
splsda.result <- splsda(myX, myY, keepX = c(50,30)) # run the method
plotIndiv(splsda.result, group = my_pipeSummary2$Type2, ind.names = FALSE, legend = TRUE)
plotVar(splsda.result) # plot the variables

# extract the variables used to construct the first latent component
selectVar(splsda.result, comp = 1)$name 
# depict weight assigned to each of these variables
plotLoadings(splsda.result, method = 'mean', contrib = 'max')  
# THIS GRAPH IS INTERESTING!

